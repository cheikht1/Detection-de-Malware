import pefile
from flask import Flask, render_template, request, jsonify
import joblib
import pandas as pd
from sklearn.preprocessing import StandardScaler

app = Flask(__name__)

# Charger le meilleur modèle
best_model = joblib.load('bff.pkl')

# Fonction pour mettre à l'échelle les données
def scale_data(X):
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    return X_scaled

# Fonction pour extraire les caractéristiques d'un fichier exécutable
def extract_features_from_exe(file_path):
    # Ouvrir le fichier exécutable avec pefile
    pe = pefile.PE(file_path)
    
    # Extraire les caractéristiques pertinentes
    features = {
        'AddressOfEntryPoint': pe.OPTIONAL_HEADER.AddressOfEntryPoint,
        'MajorLinkerVersion': pe.OPTIONAL_HEADER.MajorLinkerVersion,
        'MajorImageVersion': pe.OPTIONAL_HEADER.MajorImageVersion,
        'MajorOperatingSystemVersion': pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
        'DllCharacteristics': pe.OPTIONAL_HEADER.DllCharacteristics,
        'SizeOfStackReserve': pe.OPTIONAL_HEADER.SizeOfStackReserve,
        'NumberOfSections': len(pe.sections),
        'ResourceSize': pe.OPTIONAL_HEADER.SizeOfImage  # Utiliser SizeOfImage au lieu de len(pe.resources)
    }
    
    return features


# Routes Flask
@app.route('/', methods=['GET'])
def home():
    return render_template('index.html')

@app.route('/predict', methods=['POST'])
def predict():
    # Récupérer le fichier exécutable soumis par l'utilisateur
    file = request.files['file']
    
    # Enregistrer le fichier sur le disque
    file_path = 'uploads/' + file.filename
    file.save(file_path)
    
    # Extraire les caractéristiques du fichier exécutable en utilisant le chemin du fichier enregistré
    file_features = extract_features_from_exe(file_path)
    
    # Créer un DataFrame pandas à partir des caractéristiques
    df = pd.DataFrame([file_features])
    
    # Mettre à l'échelle les données
    X_scaled = scale_data(df)
    
    # Faire la prédiction
    prediction = best_model.predict(X_scaled)
    
    # Convertir la prédiction en texte
    prediction_text = 'Malware détecté' if prediction == 1 else 'Aucun malware détecté'
    
    # Retourner la prédiction au client
    return jsonify({'prediction': prediction_text})


if __name__ == '__main__':
    app.run(debug=True)
